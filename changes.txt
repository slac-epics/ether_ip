-*- outline -*-

This file contains information about the version numbers
and what's changed.
Hopefully, the #defines ETHERIP_MAYOR and ETHERIP_MINOR
in ether_ipApp/src/drvEtherIP.h are updated accordingly,
so that you can see the current version at runtime via
drvEtherIP_report.

* 2004, 3/17 V2.5
The timing was wrong under R3.13, keeping the driver thread
from sleeping. The code always uses the R3.14-type epicsTimeStamp,
epicsTimeGetCurrent, epicsThreadSleep etc.  When running under
R3.13, compatibility code implements the missing R3.14 routines.
Those compatibility routines contained a pretty dumb error after the
deadlock-fix from V2.4.

Symptoms include:
- driver thread used a lot of CPU in the "spy" report.
- The "scan thread slow" count in the drvEtherIP_report
  would increment by hundreds per second.
- All that kept the driver thread from using 100% of the
  CPU and flooding the network was the slow response of the
  PLC, which kept the network load within 1% in a test
  in my office.
 
The CPU usage of the driver thread in the "spy" report
is now back to 0% for test.db, sometimes going up to 3%.
The "scan task slow" messages are almost completely gone
under vxWorks w/ R3.13.9, where the "epicsTimeStamp" compatibility
routines use VX ticks.
Under R3.14, the epicsTime.. and epicsThreadSleep.. routines
end up converting between VX ticks, the wallclock, and back.
As a result, the scheduling isn't that perfect. Even after
considering the epicsThreadSleepQuantum, the "scan thread slow"
count can increment every few minutes.
All that means is that a scan list has been due for 1 or two
VX ticks (typically 0 ... 0.03 secs) and the driver overslept.
Compared to the network delays of talking to the PLC, that's
neglectable and not worth reverting to vxWorks-only code.

* 2004, 3/2 V2.4
Review of the R3.14 changes.

Using R3.14 epicsThreadPriorityHigh for the driver thread.
Before, the driver ran below the database, meaning that
the database could be forced to wait for the driver.

Replaced epicsEvent... calls with epicsMutex...:
EpicsMutex is based (for vxWorks) on the semM-type,
providing inversion safety etc.
Unfortunately, epicsMutex doesn't implement any
lock-with-timeout, so whenever we used to run into
a timeout, we're now hung.
One such instance was between the driver thread
and the database: Callbacks from the driver into
device support triggered processing of records.
A deadlock resulted when a record, being processed,
wanted to access the driver tag data, while at the
same time the driver had that tag locked and wanted
to process the record, hanging in dbLock.
The symptom:
   "tag <tagname>: no lock"
messages, then after a timeout things went on
and the record was temporarily INVALID.
For some reason this only happened under vxWorks,
I'be never seen it under Linux with same EPICS database.

Looks like that's resolved.

In case another hangup occurs, try:
     epicsMutexShowAll 1, 10
which lists all locked mutexes and the threads
waiting for them.

* 2004, 02/11 V2.3 
(CVS Release Tag --> ether_ip-2-3)
Create munch file to support
IOC run-time loading (RTL) of
the ether_ip driver libraries

* 2003, 10/31 V2.2
R3.14.4 port

* V2.1
waveform supports CHAR

* 2003, 04/29 V2.0
Stephanie Allison, saa@SLAC.Stanford.EDU, 
ported the EtherIP support to EPICS R3.14!
This added some #ifdefs, the R3.13 support
is hopefully as before.

With R3.14 it now seems to run on
- mv167/vxWorks/R3.13.6
- ppc604/vxWorks/R3.14.1
- ppc604/RTEMS/R3.14.1
- sparc/solaris/R3.14.1
- Linux (RedHat 8.0)

Thanks a lot to Stephanie!

* V1.11
forgot what changed

* 2002, 10/16 V1.10
Tested read access for various numbers of scalar and array tags.
Found that all is OK until either the request or response buffer
reaches 538 bytes. Unclear how "538" relates to the numbers "504"
or "511" found in the EtherIP spec.

Hopefully fixed the driver:
Before, only the read/write and data portion were limited to 500 bytes,
now the total is limited to 538 bytes.

* 2002, 10/15
Pilar created a perfectly fine database that causes
communication errors, causing the PLC to return an error code
that indicates "does not fit in buffer".

There is a limit for the PLC transfer buffer, about 500 bytes.
Spec page P. 2-5 mentions "504 bytes" as the CIP UCMM limit,
Spec page 156 in version 2.0, errata 2 mentions "511 bytes"
as the "Forward_Open" connection size limit.

None if this tells me exactly where the limit is
and whether it's 500 or 504 or ??
Is it in the PLC controller, so the Ethernet overhead
(encapsulation header) is handled by the ENET module
and does not count?
Is it in the ENET module, so the total inc. encapsulation
is limited?

Introduced a new EIP_PROTOCOL_OVERHEAD macro
based on the encapsulation header size
which for now reduces the used buffer size to 446 bytes.

* 2002, 10/02 V1.9
Support for stringin record and STRING type tags

* 2002, 09/24 V1.8
Better handling of disconnects and re-connects for output
records.

Input records are usually scanned. They change when
the value of the PLC tag changes, they turn READ/INVALID
when the tag isn't found on the PLC or when the connection
to the PLC goes down.

For output records, this was meant to be similar:
Most of the time, the driver _reads_ the tags used in output records.
Only when the output record is processed, the driver _writes_ the tag
(in fact the whole array when the tag is part of an array).
Whenever the driver notices a difference between the tag's value
read from the PLC and the output record, it updates the record and
processes it.
What the driver didn't do: Update output records when the PLC
disconnects. Before, one would have to process the output record
(example: Enter new value on screen) and only then would the output
record change to INVALID/WRITE.

Now output records get reprocessed not only for value discrepancies
but also for missing values (disconnect).

* 2002, 08/15 V1.7
When you omit the call to 
     drvEtherIP_define_PLC  <plc>, <IP>, <slot>
the driver (actually device support) reports
"unknown PLC xxx".
This is an indication of a severe error in
either the EPICS database or vxWorks startup script:
All PLCs that you intend to use must be defined,
the driver cannot guess to what PLC you intend to talk.

Before V1.7, the driver used to run into follow-up errors
that suspended scan tasks which included analog input records
which tried to access that unknown PLC.

From V1.7 on, those AI records will just show
INVALID/READ severity and status but no longer
suspend the scan task.

Note: Omitting the call drvEtherIP_define_PLC
is still highly discouraged.
The fix is just a little nicer than the previous
behavior.

* 2002, 06/26 V1.6
This part is not new but just a description
of current behavior of AI, AO records:
When attached to REAL (float) tags,
they read & write the (floating point) VAL fields.
For INT, DINT, ... tags they use the RVAL fields.

RVAL is a signed long,
all INT, DINT tags of the PLC are signed,
but for some reason I happened to transfer them
as "unsigned".
New: I now use signed values.

* 2002, 05/09
Log message for "EIP: Cannot read tag"
didn't show the tag but garbage.

* 2002, 04/30 V1.5
SCAN="I/O Intr" was broken.

* 2002, 03/15 V1.4
Hopefully fixed a problem that occurs when device requests write while
driver is in the middle of a read (used to look as if the PLC didn't
get the write)

* 2002, 02-19 V1.3

** Added "FORCE" option to output records
Per default, output records scan when they are
not writing a new value.
If they notice that the PLC has a different value
for the tag, teh record will adapt the tag's value.

With the new force option, the output record will
try to re-write until the PLC tag matches the
value of the record.

* 2001, 10-01 V1.2

** New driver option "drvEtherIP_default_rate"

* 2001, 08-30 (not versioned)

** Patch to output records
Output records are for writing to the PLC.
But most of the time they are readong from the PLC
and if there is a difference between the record's value
and the PLC tag, the record is updated and processed.

New: This will now happen if the record is UDF.
Before, a record would start as UDF, value 0,
and unless the tag happened to be !=0, the record
stayed UDF. Now the record will be updated/initialized
after e.g. a reboot with the tag value.

* 2001, 06-19    V1.1

** New "B <bit>" flag:
Allows connection of binary records to non-BOOL arrays like INT, DINT.
With B <bit> flag, the array element is used as is
(no longer interpreted as a bit element) and the bit within the INT
or DINT is selected via the new flag:

   INP="@plc1 DINTs[40]"
still results in reading bit 40, that is bit 8 in the second
DINT.

Now this can be written as
   INP="@plc1 DINTs[1] B 8"

A lot of ether_ipApp/doc/readme.txt, the "manual", has been rewritten.


* 2001, 05-18    V1.0

** New "slot" parameter: drvEtherIP_define_PLC <name>, <ip_addr>, <slot>

Before, the driver assumed that the PLC would be in slot 0,
the left-most slot of the ControlLogix crate.

Now you can put it anywhere (in the crate),
but if it's not slot 0, you have to specify that
when you define the PLC.

** Some changes to output of drvEtherIP_report
Now displaying the PLC interface info, e.g.:
  Interface name        : 1756-ENET/A 
  Interface vendor      : 0x100
  Interface type        : 0xC00
  Interface revision    : 0x112
  Interface serial      : 0x13D40700


